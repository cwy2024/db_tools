SQL语言
分类
SQL语言可被分为五类：
- 数据查询语言DQL:Data Query Language，用于查询表中的数据。
- 数据操纵语言DML：Data Manipulation Language，用来处理数据库中的数据内容，允许用户对数据库中的数据进行查询 ，插入，更新和删除等操作。对表数据的增删改。
- 数据定义语言DDL：Data Definition Language， 用于创建、删除和修改数据库对象，并且将对这些对象的定义保存到数据字典中。对表结构的增删改。
- 数据控制语言DCL：Data Control Language，用于控制数据访问权限，主要是管理特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。
- 事务控制语言TCL：Transaction Control Language，控制事务的提交或回滚。
通常，DQL可被归属为DML，TCL可被归属为DCL。


mysql常用基础命令
- 登陆mysql：
mysql -uroot -p
-  查看mysql版本号：
mysql -V
- 查看数据库：
show databases;
// 查看\描述表结构
describe <表名>;   || desc <表名>;
// 以SQL语句的形式展示表结构\描述创建表使用的sql语句
SHOW CREATE TABLE <表名>；
- 创建名称为“test”的数据库：
create database test;
-- 使用名为test的数据库
use test;
-- 查询当前使用的数据库
select database();
-- 查询数据库版本
select version();
-- show ndb status; #查看vedb服务器状态
-- show slave status\G; # 查看主从的状态
- 查看当前使用的数据库中都有哪些表格
show tables;
// 查看test数据库的表
show tables from test;
- 导入初始化数据
source /Users/bytedance/Desktop/automated_test/TPC-H_Tools_0729/dbgen/dss.ddl
#dss.ddl内部为"CREATE TABLE NATION"等语句
- 查看用户正在运行的线程：
show processlist;
- 查看系统参数：
#开启load data local本地数据载入权限
show variables like "local_infile";
SET GLOBAL local_infile = 'ON';
set global log_bin_trust_function_creators = 1;

# 对比系统环境变量是否一致，排除外界因素
mysql> SHOW VARIABLES LIKE '%character%';
+--------------------------+--------------------------------+
| Variable_name            | Value                          |
+--------------------------+--------------------------------+
| character_set_client     | utf8mb4                        |
| character_set_connection | utf8mb4                        |
| character_set_database   | utf8mb4                        |
| character_set_filesystem | binary                         |
| character_set_results    | utf8mb4                        |
| character_set_server     | utf8mb4                        |
| character_set_system     | utf8mb3                        |
| character_sets_dir       | /opt/tiger/ndb/share/charsets/ |
+--------------------------+--------------------------------+
8 rows in set (0.05 sec)

#查看mysql支持的字符集
mysql> show character set;
终止一条语句：\C
退出mysql：\q，quit，exit；
DQL详解：
select 语句
SELECT
{* | <字段列名>}
[
FROM <表 1>, <表 2>…
[WHERE <表达式>
[GROUP BY <group by definition>
[HAVING <expression> [{<operator> <expression>}…]]
[ORDER BY <order by definition>]
[LIMIT[<offset>,] <row count>] [ OFFSET M]
]
常用方式：
- 显示所有数据：
select * from table_name;
- 显示某几列数据：
select column1,column2 from table_name; 
- 仅显示前10行数据：
select * from table_name limit 10;

---
Distinct 关键词：
DISTINCT 关键词用于返回唯一不同的值:
select distinct column1,column2 from table_name;
示例：
select distinct a,c from t1;  #默认顺序选择a,c组合不同的字段进行显示

---
Where关键词:
WHERE 子句用于提取那些满足指定条件的记录:
SELECT field1, field2,...fieldN FROM table_name1, table_name2...
WHERE condition1 [AND] [OR] condition2.....
[图片]
挑选c处于[70,90]的记录：
select a,b from t1 where c >=70 and c <= 90;
- 逻辑运算的优先级：
()
not
and
or
- 特殊条件
空值判断 
is null
Select * from emp where comm is null;
查询 emp 表中 comm 列中的空值
在 之间的值
between and 

Select * from emp where sal between 1500 and 3000;
 查询 emp 表中 SAL 列中大于 1500 (含1500)的小于 3000（含3000） 的值。
包含（等于）

In

Select * from emp where sal in (5000,3000,1500);

查询 EMP 表 SAL 列中等于 5000，3000，1500 的值。
模糊查询

like

Select * from emp where ename like 'M%';

查询 EMP 表中 Ename 列中有 M 的值，M 为要查询内容中的模糊信息。


---
GROUP BY关键词
SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
函数
说明
示例
SUM
计算某一列的合计值，该列必须为数值类型
SELECT SUM(column_name) FROM table_name;
AVG
计算某一列的平均值，该列必须为数值类型
SELECT AVG(column_name) FROM table_name
MAX
计算某一列的最大值
SELECT MAX(column_name) FROM table_name;
MIN
计算某一列的最小值
SELECT MIN(column_name) FROM table_name;
COUNT(*)
返回指定列的值的数目（NULL 不计入）
SELECT COUNT(column_name) FROM table_name;
统计各班的男生和女生人数：
SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;

---
Having 关键词
WHERE 关键字无法与聚合函数一起使用，HAVING 子句可以让我们筛选分组后的各组数据。MySQL函数说明
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value;
[图片]


---
ORDER BY 关键词
ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。
SELECT column_name,column_name FROM table_name 
ORDER BY column_name,column_name ASC|DESC;
查询一班的学生成绩，并按照倒序排序：
SELECT id, name, gender, score  FROM students  WHERE class_id = 1  ORDER BY score DESC;
 select * from t1 where a = 2 order by c desc;

---
LIMIT关键词
https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600
常用语法：
#显示前10行语句
select * from table_name limit 10 ;

#分页查询 LIMIT <N-M> OFFSET <M>
#select * from _table limit lines_perpage offset (page_number-1)*lines_perpage
select * from table_name limit 10 offset 0 ; #查询第一页，每页10条语句
select * from table_name limit 10 offset 100 ; #查询第十一页，跳过前100条记录

#limit N,M : 相当于 limit M offset N , 从第 N 条记录开始, 返回 M 条记录
select * from t1 limit 3 offset 1; #查询3条记录，跳过前1条记录
select * from t1 limit 4,3; #从第4条记录开始（不包括第4条），查询后续3条记录

---
mysql连接&多表查询
使用 Mysql 的 JOIN 可以实现联合多表查询
[图片]
- INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
连接两张表，读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值
SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;
查询 学生id 对应的 课程 以及 花销 
[图片]
- LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。
SELECT column_name(s) FROM table1 
LEFT JOIN table2 
ON table1.column_name=table2.column_name;
[图片]
- RIGHT JOIN（右连接）： 获取右表所有记录，即使左表没有对应匹配的记录。
RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。
SELECT column_name(s) FROM table1 
RIGHT JOIN table2 
ON table1.column_name=table2.column_name;
[图片]
- CROSS JOIN（交叉连接，笛卡尔连接）：该结果集是两个关联表的行的乘积。通常，如果每个表分别具有n和m行，则结果集将具有n*m行
注意：cross join的时候是不需要on或者using关键字的，这个是区别于inner join和join的
SELECT * 
FROM table111
LEFT JOIN(table112 CROSS JOIN table113)
ON table111.id=table113.id;
-- 示例：查询温度比前一天高的数据
select a.id as id from Weather as a cross join  Weather as b where datediff(a.recordDate, b.recordDate) = 1 and a.temperature > b.temperature;
[图片]
数据库中内连接与多表查询的区别
sql = "select [个人信息$].*,[工作经历$].* from [个人信息$],[工作经历$] where [个人信息$].UID=[工作经历$].UID"
sql = "select [个人信息$].*,[工作经历$].* from [个人信息$] inner  join [工作经历$] on [个人信息$].UID=[工作经历$].UID"
第一种是普通的多表查询，内部还是笛卡尔积的逐行的搜索机制，如果查询的几张表数据量大的话会降低性能；
第二种是内连接。两种方式得到的结果是一致的。inner join(等值连接) 只返回两个表中联结字段相等的行的记录。
        从结果上看一样。
        但是从实现上看，多个from是笛卡尔集，再筛选，效率是O(n^2)，很差。
                                     join是先做hash，再匹配，效率是O(logN)，很好。
        推荐使用内连接。SQL规格推荐也是用join的。
DML详解：

---
instert语句
1.1 INSERT INTO 
INSERT INTO 语句用于向表中插入新记录。
INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,value2,value3,...);   #高亮部分可选
假设我们要向 "Websites" 表中插入一个新行。
INSERT INTO Websites (name, url, alexa, country)VALUES ('百度','https://www.baidu.com/','4','CN');
[图片]

---
1.2 INSERT INTO SELECT
INSERT INTO SELECT语句从一个表复制数据，然后把数据插入到一个已存在的表中
- 从一个表中复制所有的列插入到另一个已存在的表中：
INSERT INTO table2 SELECT * FROM table1;
- 复制希望的列插入到另一个已存在的表中
INSERT INTO table2 (column_name(s)) SELECT column_name(s) FROM table1;
在数据库 test_db 中创建一个与 tb_courses 表结构相同的数据表 tb_courses_new
CREATE TABLE tb_courses_new ( course_id INT NOT NULL AUTO_INCREMENT, course_name CHAR(40) NOT NULL,  course_grade FLOAT NOT NULL,  course_info CHAR(100) NULL, PRIMARY KEY(course_id) );
从 tb_courses 表中查询所有的记录，并将其插入 tb_courses_new 表中
INSERT INTO tb_courses_new  (course_id,course_name,course_grade,course_info)  SELECT course_id,course_name,course_grade,course_info  FROM tb_courses;
# insert into tb_courses_new select * from tb_courses_new；

---
updata语句
UPDATE table_name SET column1=value1,column2=value2,... WHERE some_column=some_value;
更新数据表中 runoob_id 为 3 的 runoob_title 字段值：
UPDATE runoob_tbl SET runoob_title='学习 C++' WHERE runoob_id=3;

---
delete语句
DELETE FROM table_name WHERE some_column=some_value;
DELETE 语句用于删除表中的行。
DELETE FROM <表名> [WHERE 子句] [ORDER BY 子句] [LIMIT 子句]
删除 tb_courses_new 表中的全部数据
DELETE FROM tb_courses_new;
从 "Websites" 表中删除网站名为 "Facebook" 且国家为 USA 的网站
DELETE FROM Websites WHERE name='Facebook' AND country='USA';

---
DDL详解：

---
create语句
1. 创建数据库
创建数据库，语法格式如下所示：
CREATE DATABASE dbname;
创建一个名为 "my_db" 的数据库：
CREATE DATABASE my_db;

---
2. 创建表
创建数据表，SQL语句格式如下所示：
CREATE TABLE table_name ( column_name1 data_type(size), column_name2 data_type(size), column_name3 data_type(size), .... );
column_name 参数规定表中列的名称；data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）；size 参数规定表中列的最大长度
在 MySQL 中，可以使用 CREATE TABLE 语句创建表。其语法格式为：
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    (create_definition,...)
    [table_options]
    [partition_options]
//CREATE TABLE <表名> ([表定义选项])[表选项][分区选项];
- <表定义选项>：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。
//示例：
CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id` INT UNSIGNED AUTO_INCREMENT,
   `runoob_title` VARCHAR(100) NOT NULL,
   `runoob_author` VARCHAR(40) NOT NULL,
   `submission_date` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
创建一个名为 "Persons" 的表，包含五列：PersonID、LastName、FirstName、Address 和 City。
PersonID 列的数据类型是 int，包含整数。LastName、FirstName、Address 和 City 列的数据类型是 varchar，包含字符，且这些字段的最大长度为 255 个字符。
CREATE TABLE Persons ( PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) );

---
3. 创建视图
MySQL 视图（View）是一种虚拟存在的表，同真实表一样，视图也由列和行构成，但视图并不实际存在于数据库中。行和列的数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成的。
CREATE VIEW <视图名> AS <SELECT语句>
在 tb_students_info 表上创建一个名为 v_students_info 的视图
[图片]

---
4. 创建索引
//创建索引
CREATE <索引名> ON <表名> (<列名> [<长度>] [ ASC | DESC])
CREATE INDEX indexName ON table_name (column_name)
//修改表结构(添加索引)
ALTER table tableName ADD INDEX indexName(columnName)
//查看索引
SHOW INDEX FROM <表名> [ FROM <数据库名>]
//删除索引
DROP INDEX <索引名> ON <表名>
CREATE TABLE table_name [col_name data type] [unique|fulltext] [index|key] [index_name] (col_name[length]) [asc|desc]
- 1.unique|fulltext为可选参数，分别表示唯一索引、全文索引 ,PRIMARY主键索引
- 2.index和key为同义词，两者作用相同，用来指定创建索引 
- 3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择 
- 4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值 
- 5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度 
- 6.asc或desc指定升序或降序的索引值存储
示例：
 创建一个表 tb_stu_info2，在该表的 id 字段上使用 UNIQUE 关键字创建唯一索引。
CREATE TABLE tb_stu_info2 ( id INT NOT NULL, name CHAR(45) DEFAULT NULL,, height INT DEFAULT NULL,  UNIQUE KEY (height) );
创建主键索引：
CREATE TABLE table (id int NOT NULL AUTO_INCREMENT , title char NOT NULL , PRIMARY KEY (id));  
组合索引:
ALTER TABLE table_name ADD INDEX name_city_age (name,city,age); 
全文索引：
CREATE FULLTEXT INDEX index_content ON article(content);
查看tb_stu_info2 数据表的索引信息
SHOW INDEX FROM tb_stu_info2\G
删除表 tb_stu_info 中的索引
DROP INDEX height ON tb_stu_info;
SHOW CREATE TABLE tb_stu_info\G

---
alter语句
在 MySQL 中可以使用 ALTER TABLE 语句来改变原有表的结构，例如增加或删减列、更改原有列类型、重新命名列或表等。
语法格式如下：
ALTER TABLE <表名> [修改选项]

---
1.1 修改表名、字符集、引擎等
- 实现表名的修改：
ALTER TABLE <旧表名> RENAME [TO] <新表名>；
数据表 student 改名为 tb_students_info：
ALTER TABLE student RENAME TO tb_students_info;
- 修改表字符集
ALTER TABLE 表名 [DEFAULT] CHARACTER SET <字符集名> [DEFAULT] COLLATE <校对规则名>;
其中，DEFAULT 为可选参数，使用与否均不影响结果。
使用 ALTER TABLE 将数据表 tb_students_info 的字符集修改为 gb2312，校对规则修改为 gb2312_chinese_ci：
ALTER TABLE tb_students_info CHARACTER SET gb2312  DEFAULT COLLATE gb2312_chinese_ci;
- 修改表引擎
ALTER TABLE testalter_tbl ENGINE = MYISAM;

---
1.2 修改字段
- 修改字段名称
ALTER TABLE <表名> CHANGE <旧字段名> <新字段名> <新数据类型>；
修改表 tb_emp1 的结构，将 col1 字段名称改为 col3，同时将数据类型变为 CHAR(30)：
ALTER TABLE tb_emp1 CHANGE col1 col3 CHAR(30);
DESC tb_emp1;
- 修改字段数据类型
ALTER TABLE <表名> MODIFY <字段名> <数据类型>
修改表 tb_emp1 的结构，将 name 字段的数据类型由 VARCHAR(22) 修改成 VARCHAR(30：
ALTER TABLE tb_emp1 MODIFY name VARCHAR(30);
修改字段时，你可以指定是否包含值或者是否设置默认值：
指定表testalter_tbl 字段 j 为 NOT NULL 且默认值为100：
ALTER TABLE testalter_tbl  MODIFY j BIGINT NOT NULL DEFAULT 100;
- 修改字段默认值
ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;
[图片]
- 使用 ALTER 命令及 DROP子句来删除字段的默认值
ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;

---
1.3 删除字段
- 删除字段
ALTER TABLE <表名> DROP <字段名>；
修改表 tb_emp1 的结构，删除 col2 字段：
ALTER TABLE tb_emp1 DROP col2;

---
1.4 添加字段
- 在末尾添加字段
ALTER TABLE <表名> ADD <新字段名><数据类型>[约束条件];
默认在 student 表的最后位置（最后一列的后面）添加新字段，添加一个 INT 类型的字段 age：
ALTER TABLE student ADD age INT(4);
- 在开头添加字段
ALTER TABLE <表名> ADD <新字段名> <数据类型> [约束条件] FIRST;
在 student 表的第一列添加 INT 类型的字段 stuId：
ALTER TABLE student ADD stuId INT(4) FIRST;
- 在中间位置添加字段
MySQL 除了允许在表的开头位置和末尾位置添加字段外，还允许在中间位置（指定的字段之后）添加字段，此时需要使用 AFTER 关键字，语法格式如下：
ALTER TABLE <表名> ADD <新字段名> <数据类型> [约束条件] AFTER <已经存在的字段名>;
在 student 表中添加名为 stuno，数据类型为 INT 的字段，stuno 字段位于 name 字段的后面：
ALTER TABLE student ADD stuno INT(11) AFTER name;

---
drop语句
删除数据库：
drop database <数据库名>;
删除数据表：
DROP TABLE <table_name> ; 
DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...]
删除表中的索引：
ALTER TABLE <table_name> DROP INDEX <index_name>；
删除视图：
DROP VIEW <视图名1> [ , <视图名2> …]

---
DCL详解：

TCL详解：
保存点与回滚
保存点savepoint一般与回滚rollback配合使用。在设置了savepoint后事务的粒度可以控制的更加细化，可以回滚到特定的保存点。
【语法】保存点savepoint
SAVEPOINT <savepoint_name>;
【示例】
--创建一个保存点，名称为a
savepoint a;
当创建保存点之后执行的DML操作，可以进行回滚，而保存点之前未提交的DML操作不受影响。
【语法】回滚
ROLLBACK [TO savepoint];
【示例】
--回滚到保存点a,即在保存点a之后的所有未提交的DML都无效。
rollback to a;
--1、创建保存点a
savepoint a;
--2、插入emp数据 it1
insert into emp(empno,ename) values(1234,'it1');
--3、创建保存点b
savepoint b;
--4、插入emp数据 it2
insert into emp(empno,ename) values(1235,'it2');
--5、查看emp表数据，存在it1、it2两条数据
select ename from emp;
--6、回滚到保存点b，即it2数据将消失
rollback to b;
--7、查看emp表数据，存在it1的数据，it2已不在
select ename from emp;
--8、提交数据
commit;
--9、查看emp表数据，存在it1的数据
select ename from emp;
--10、回滚到保存点a，将报错保存点不存在的错误信息
rollback to a;
 事务提交与回滚
# 开启事务：
SET autocommit=0; 
START TRANSACTION;
#编写事务语句
DELETE FROM account WHERE id=25;
#结束事务
ROLLBACK; //如果是已经结束事务后（commit）再提交回滚，不会对结果进行改变；因为内容已经从内存提交到磁盘中。 //commit

MySQL正则表达式
参考：https://www.runoob.com/mysql/mysql-regexp.html
MySQL 中使用 REGEXP 和 RLIKE操作符来进行正则表达式匹配
正则表达式匹配的字符类：
.：匹配任意单个字符。
^：匹配字符串的开始。
$：匹配字符串的结束。
*：匹配零个或多个前面的元素。
+：匹配一个或多个前面的元素。
?：匹配零个或一个前面的元素。
[abc]：匹配字符集中的任意一个字符。
[^abc]：匹配除了字符集中的任意一个字符以外的字符。
[a-z]：匹配范围内的任意一个小写字母。
[0-9]：匹配一个数字字符。
\w：匹配一个字母数字字符（包括下划线）。
\s：匹配一个空白字符。
[图片]
1. 使用 REGEXP 进行模式匹配
-- 'pattern' 是一个正则表达式模式, BINARY 关键字，使得匹配区分大小写； 
-- RLIKE 与 REGEXP 是一样的，RLIKE 和 REGEXP 可以互换使用
SELECT column1, column2, ...
FROM table_name
WHERE column_name REGEXP [BINARY] 'pattern';
-- 示例
-- 查找 name 字段中以 'st' 为开头的所有数据：
select name from person_tbl where name regrxp '^st';
-- 查找 name 字段中以 'ok' 为结尾的所有数据：
select name from person_tbl where name regrxp 'st$';
-- 查找 name 字段中包含 'mar' 字符串的所有数据：
select name from person_tbl where name regrxp 'mar';
-- 查找 name 字段中以元音字符开头或以 'ok' 字符串结尾的所有数据：
select name from person_tbl where name regrxp '^ok|^[aeiou]';
-- 选择订单表中描述中包含 "item" 后跟一个或多个数字的记录。
select * from orders where order_description regrxp 'item[0-9]+'

MySQL常用数据构造
create table test_company (
    id int(20) not null auto_increment primary key, 
    name varchar(30) not null default 'bytedancer' comment '名称',
    email char(60) not null comment '邮箱',
    gender enum('male', 'female') not null comment '性别',
    salary DECIMAL(10,2) not null default 20000.00 comment '薪资',
    description text default null comment '描述',
    photo tinyblob default null comment '头像',
    hire_date timestamp(6) not null default current_timestamp(6) comment '入职日期',
    json_data json null comment '擅长项目',
    unique key email_idx using BTREE (`email`)
)engine=innodb default character set="utf8mb4" collate = "utf8mb4_general_ci";
常用函数
1. 排序函数
https://www.cnblogs.com/52XF/p/4209211.html
1. ROW_NUMBER
select ROW_NUMBER() OVER(order by [SubTime] desc) as row_num,* from [Order]
[图片]
2. rank()
select RANK() OVER(order by [UserId]) as rank,* from [Order] 
[图片]
3. dense_rank()
select DENSE_RANK() OVER(order by [UserId]) as den_rank,* from [Order]
[图片]

2. MySQL常用函数
MySQL SQL学习笔记
https://www.runoob.com/mysql/mysql-functions.html
MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)
